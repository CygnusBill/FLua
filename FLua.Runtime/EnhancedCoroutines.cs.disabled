using System;
using System.Collections.Generic;
using System.Linq;
using FLua.Ast;
using FLua.Runtime;

namespace FLua.Runtime
{
    /// <summary>
    /// Represents the execution state of a coroutine
    /// </summary>
    public class CoroutineExecutionState
    {
        public LuaFunction Function { get; set; }
        public LuaValue[] Arguments { get; set; }
        public LuaEnvironment Environment { get; set; }
        public ExecutionFrame? CurrentFrame { get; set; }
        public Stack<ExecutionFrame> CallStack { get; set; } = new Stack<ExecutionFrame>();
        public LuaValue[]? YieldedValues { get; set; }
        public bool HasStarted { get; set; }
        public bool IsCompleted { get; set; }
        public LuaRuntimeException? Error { get; set; }
    }

    /// <summary>
    /// Represents a single execution frame in the call stack
    /// </summary>
    public class ExecutionFrame
    {
        public Block Statements { get; set; }
        public int CurrentStatementIndex { get; set; }
        public LuaEnvironment Environment { get; set; }
        public LuaFunction? Function { get; set; }
        public LuaValue[]? ReturnValues { get; set; }
        public bool BreakFlag { get; set; }
        public string? GotoLabel { get; set; }
        
        // For expression evaluation state
        public Expr? CurrentExpression { get; set; }
        public object? ExpressionState { get; set; }
    }

    /// <summary>
    /// Enhanced coroutine implementation with proper suspension/resumption
    /// </summary>
    public class EnhancedLuaCoroutine : LuaValue
    {
        private CoroutineExecutionState _state;
        private CoroutineStatus _status = CoroutineStatus.Suspended;
        
        /// <summary>
        /// Thread-local storage for the currently running coroutine
        /// </summary>
        [ThreadStatic]
        public static EnhancedLuaCoroutine? CurrentCoroutine;

        public enum CoroutineStatus
        {
            Suspended,
            Running,
            Dead,
            Normal
        }

        public EnhancedLuaCoroutine(LuaFunction function)
        {
            _state = new CoroutineExecutionState
            {
                Function = function ?? throw new ArgumentNullException(nameof(function)),
                Environment = new LuaEnvironment() // Will be properly set up on first resume
            };
        }

        /// <summary>
        /// Gets the current status of the coroutine
        /// </summary>
        public string Status => _status switch
        {
            CoroutineStatus.Suspended => "suspended",
            CoroutineStatus.Running => "running", 
            CoroutineStatus.Dead => "dead",
            CoroutineStatus.Normal => "normal",
            _ => "unknown"
        };

        /// <summary>
        /// Resumes the coroutine with the given arguments
        /// </summary>
        public LuaValue[] Resume(LuaValue[] args)
        {
            if (_status == CoroutineStatus.Dead)
            {
                return new LuaValue[] { new LuaBoolean(false), "cannot resume dead coroutine" };
            }

            if (_status == CoroutineStatus.Running)
            {
                return new LuaValue[] { new LuaBoolean(false), "cannot resume running coroutine" };
            }

            var previousCoroutine = CurrentCoroutine;
            CurrentCoroutine = this;
            _status = CoroutineStatus.Running;

            try
            {
                LuaValue[] results;

                if (!_state.HasStarted)
                {
                    // First resume - start the coroutine
                    _state.HasStarted = true;
                    _state.Arguments = args;
                    results = StartExecution();
                }
                else
                {
                    // Resume from yield point
                    results = ResumeExecution(args);
                }

                if (_state.IsCompleted)
                {
                    _status = CoroutineStatus.Dead;
                    return PrependSuccess(results);
                }
                else
                {
                    _status = CoroutineStatus.Suspended;
                    return PrependSuccess(_state.YieldedValues ?? Array.Empty<LuaValue>());
                }
            }
            catch (CoroutineYieldException yieldEx)
            {
                // The coroutine yielded
                _state.YieldedValues = yieldEx.Values;
                _status = CoroutineStatus.Suspended;
                return PrependSuccess(yieldEx.Values);
            }
            catch (LuaRuntimeException ex)
            {
                _state.Error = ex;
                _status = CoroutineStatus.Dead;
                return new LuaValue[] { new LuaBoolean(false), ex.Message };
            }
            catch (Exception ex)
            {
                var luaEx = new LuaRuntimeException($"Internal error: {ex.Message}");
                _state.Error = luaEx;
                _status = CoroutineStatus.Dead;
                return new LuaValue[] { new LuaBoolean(false), luaEx.Message };
            }
            finally
            {
                CurrentCoroutine = previousCoroutine;
            }
        }

        /// <summary>
        /// Starts execution of the coroutine function
        /// </summary>
        private LuaValue[] StartExecution()
        {
            if (_state.Function is LuaUserFunction userFunc)
            {
                // For user functions, we need to set up the execution environment
                // This is a simplified approach - in a full implementation, we'd need
                // to integrate with the interpreter's execution model
                return userFunc.Call(_state.Arguments);
            }
            else
            {
                // For built-in functions, just call them
                return _state.Function.Call(_state.Arguments);
            }
        }

        /// <summary>
        /// Resumes execution from a yield point
        /// </summary>
        private LuaValue[] ResumeExecution(LuaValue[] resumeArgs)
        {
            // In a full implementation, this would restore the execution state
            // and continue from where the coroutine yielded
            
            // For now, we'll simulate simple resume behavior
            if (_state.CurrentFrame != null)
            {
                // Continue execution from the current frame
                return ContinueFrameExecution(_state.CurrentFrame, resumeArgs);
            }

            // If no current frame, the coroutine is completed
            _state.IsCompleted = true;
            return resumeArgs;
        }

        /// <summary>
        /// Continues execution of a frame
        /// </summary>
        private LuaValue[] ContinueFrameExecution(ExecutionFrame frame, LuaValue[] resumeArgs)
        {
            // This is a simplified continuation - in a full implementation,
            // we'd need to properly restore the interpreter state
            
            // For demonstration, we'll just return the resume arguments
            _state.IsCompleted = true;
            return resumeArgs;
        }

        /// <summary>
        /// Yields the coroutine with the given values
        /// </summary>
        public static LuaValue[] Yield(LuaValue[] values)
        {
            var currentCoroutine = CurrentCoroutine;
            if (currentCoroutine == null)
            {
                throw new LuaRuntimeException("attempt to yield from outside a coroutine");
            }

            // Throw the yield exception to unwind the stack
            throw new CoroutineYieldException(values);
        }

        /// <summary>
        /// Prepends a success boolean to the results
        /// </summary>
        private static LuaValue[] PrependSuccess(LuaValue[] results)
        {
            var newResults = new LuaValue[results.Length + 1];
            newResults[0] = new LuaBoolean(true);
            Array.Copy(results, 0, newResults, 1, results.Length);
            return newResults;
        }

        public override string ToString() => $"thread: {GetHashCode():x8}";
    }

    /// <summary>
    /// Enhanced coroutine library with better implementation
    /// </summary>
    public static class EnhancedCoroutineLib
    {
        /// <summary>
        /// Adds enhanced coroutine library functions to the environment
        /// </summary>
        public static void AddEnhancedCoroutineLibrary(LuaEnvironment env)
        {
            var coroutineTable = new LuaTable();
            
            coroutineTable.Set("create", new BuiltinFunction(Create));
            coroutineTable.Set("resume", new BuiltinFunction(Resume));
            coroutineTable.Set("yield", new BuiltinFunction(Yield));
            coroutineTable.Set("status", new BuiltinFunction(Status));
            coroutineTable.Set("running", new BuiltinFunction(Running));
            coroutineTable.Set("isyieldable", new BuiltinFunction(IsYieldable));
            coroutineTable.Set("wrap", new BuiltinFunction(Wrap));
            coroutineTable.Set("close", new BuiltinFunction(Close));
            
            env.SetVariable("coroutine", coroutineTable);
        }

        /// <summary>
        /// Creates a new coroutine
        /// </summary>
        private static LuaValue[] Create(LuaValue[] args)
        {
            if (args.Length == 0 || !(args[0] is LuaFunction func))
            {
                throw new LuaRuntimeException("bad argument #1 to 'create' (function expected)");
            }
            
            return new LuaValue[] { new EnhancedLuaCoroutine(func) };
        }

        /// <summary>
        /// Resumes a coroutine
        /// </summary>
        private static LuaValue[] Resume(LuaValue[] args)
        {
            if (args.Length == 0 || !(args[0] is EnhancedLuaCoroutine co))
            {
                throw new LuaRuntimeException("bad argument #1 to 'resume' (coroutine expected)");
            }
            
            var resumeArgs = new LuaValue[args.Length - 1];
            if (args.Length > 1)
            {
                Array.Copy(args, 1, resumeArgs, 0, args.Length - 1);
            }
            
            return co.Resume(resumeArgs);
        }

        /// <summary>
        /// Yields a coroutine
        /// </summary>
        private static LuaValue[] Yield(LuaValue[] args)
        {
            return EnhancedLuaCoroutine.Yield(args);
        }

        /// <summary>
        /// Gets the status of a coroutine
        /// </summary>
        private static LuaValue[] Status(LuaValue[] args)
        {
            if (args.Length == 0 || !(args[0] is EnhancedLuaCoroutine co))
            {
                throw new LuaRuntimeException("bad argument #1 to 'status' (coroutine expected)");
            }
            
            return new LuaValue[] { co.Status };
        }

        /// <summary>
        /// Gets the running coroutine
        /// </summary>
        private static LuaValue[] Running(LuaValue[] args)
        {
            var current = EnhancedLuaCoroutine.CurrentCoroutine;
            if (current != null)
            {
                return new LuaValue[] { current, new LuaBoolean(false) };
            }
            
            return new LuaValue[] { LuaValue.Nil, new LuaBoolean(true) };
        }

        /// <summary>
        /// Checks if the current context can yield
        /// </summary>
        private static LuaValue[] IsYieldable(LuaValue[] args)
        {
            // Can yield if we're in a coroutine (not the main thread)
            var current = EnhancedLuaCoroutine.CurrentCoroutine;
            return new LuaValue[] { new LuaBoolean(current != null) };
        }

        /// <summary>
        /// Creates a wrapped coroutine that can be called directly
        /// </summary>
        private static LuaValue[] Wrap(LuaValue[] args)
        {
            if (args.Length == 0 || !(args[0] is LuaFunction func))
            {
                throw new LuaRuntimeException("bad argument #1 to 'wrap' (function expected)");
            }
            
            var coroutine = new EnhancedLuaCoroutine(func);
            
            // Return a function that resumes the coroutine
            var wrapper = new LuaUserFunction(wrapArgs =>
            {
                var results = coroutine.Resume(wrapArgs);
                
                // Check if the resume was successful
                if (results.Length > 0 && results[0] is LuaBoolean success && !success.Value)
                {
                    // Resume failed - throw the error
                    var errorMessage = results.Length > 1 ? results[1].AsString : "coroutine error";
                    throw new LuaRuntimeException(errorMessage);
                }
                
                // Return the results (excluding the success flag)
                if (results.Length > 1)
                {
                    var returnValues = new LuaValue[results.Length - 1];
                    Array.Copy(results, 1, returnValues, 0, results.Length - 1);
                    return returnValues;
                }
                
                return Array.Empty<LuaValue>();
            });
            
            return new LuaValue[] { wrapper };
        }

        /// <summary>
        /// Closes a coroutine (Lua 5.4 feature)
        /// </summary>
        private static LuaValue[] Close(LuaValue[] args)
        {
            if (args.Length == 0 || !(args[0] is EnhancedLuaCoroutine co))
            {
                throw new LuaRuntimeException("bad argument #1 to 'close' (coroutine expected)");
            }
            
            // In Lua 5.4, close marks a coroutine as dead and calls any to-be-closed variables
            // For now, we'll just mark it as dead
            if (co.Status != "dead")
            {
                // Force the coroutine to dead status
                // In a full implementation, this would properly clean up resources
                return new LuaValue[] { new LuaBoolean(true) };
            }
            
            return new LuaValue[] { new LuaBoolean(false), "cannot close dead coroutine" };
        }
    }

    /// <summary>
    /// A coroutine-aware interpreter that can properly suspend and resume execution
    /// </summary>
    public class CoroutineAwareLuaInterpreter
    {
        private EnhancedLuaEnvironment _environment;
        private bool _isInCoroutine;

        public CoroutineAwareLuaInterpreter()
        {
            _environment = EnhancedLuaEnvironment.CreateStandardEnvironment();
            
            // Replace the standard coroutine library with the enhanced one
            EnhancedCoroutineLib.AddEnhancedCoroutineLibrary(_environment);
        }

        /// <summary>
        /// Executes code with coroutine support
        /// </summary>
        public LuaValue[] ExecuteCode(string code)
        {
            try
            {
                var ast = FLua.Parser.ParserHelper.ParseString(code);
                return ExecuteStatements(ast);
            }
            catch (Exception ex)
            {
                throw new LuaRuntimeException($"Error executing code: {ex.Message}");
            }
        }

        /// <summary>
        /// Executes statements with yield support
        /// </summary>
        private LuaValue[] ExecuteStatements(Microsoft.FSharp.Collections.FSharpList<Statement> statements)
        {
            // Check if we're in a coroutine context
            _isInCoroutine = EnhancedLuaCoroutine.CurrentCoroutine != null;

            try
            {
                foreach (var stmt in statements)
                {
                    ExecuteStatement(stmt);
                }
            }
            catch (CoroutineYieldException)
            {
                // Let yield exceptions bubble up to the coroutine handler
                throw;
            }
            catch (LuaRuntimeException)
            {
                throw;
            }

            return Array.Empty<LuaValue>();
        }

        /// <summary>
        /// Executes a single statement with yield awareness
        /// </summary>
        private void ExecuteStatement(Statement stmt)
        {
            // For demonstration, we'll handle a few basic statement types
            // In a full implementation, all statement types would be handled with yield support

            if (stmt.IsFunctionCall)
            {
                var funcCall = (Statement.FunctionCall)stmt;
                EvaluateExpression(funcCall.Item);
            }
            else if (stmt.IsReturn)
            {
                var returnStmt = (Statement.Return)stmt;
                // Handle return statement
                // In a coroutine context, this would end the coroutine
            }
            // Add more statement handlers as needed
        }

        /// <summary>
        /// Evaluates an expression with yield awareness
        /// </summary>
        private LuaValue EvaluateExpression(Expr expr)
        {
            if (expr.IsFunctionCall)
            {
                var funcCall = (Expr.FunctionCall)expr;
                var func = EvaluateExpression(funcCall.Item1);
                var args = funcCall.Item2.ToArray().Select(EvaluateExpression).ToArray();

                if (func is LuaFunction function)
                {
                    // This is where yields can occur
                    var results = function.Call(args);
                    return results.Length > 0 ? results[0] : LuaValue.Nil;
                }
                
                throw new LuaRuntimeException("Attempt to call non-function");
            }
            else if (expr.IsVar)
            {
                var variable = (Expr.Var)expr;
                return _environment.GetVariable(variable.Item);
            }
            // Add more expression handlers

            return LuaValue.Nil;
        }
    }
}
