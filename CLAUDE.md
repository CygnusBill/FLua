# FLua Project Documentation

## Project Overview

FLua is a comprehensive Lua 5.4 parser and interpreter implementation using F# (parser) and C# (interpreter/runtime). The project aims for near-complete Lua 5.4 compatibility (~95% implemented).

### Key Technologies Used
- **Programming Languages**: F#, C#
- **Frameworks/Libraries**:
  - FParsec (for parsing in F#)
  - .NET Framework and libraries for C# components
  - Roslyn (for C# code generation)
  - Mono.Cecil (for IL generation)

### High-Level Architecture
FLua is designed with a hybrid F#/C# architecture:
- **Parser** (F#): Uses FParsec to parse Lua code into an abstract syntax tree (AST).
- **Runtime** (C#): Implements the core runtime system, including value types, environments, and standard libraries.
- **Interpreter** (C#): Evaluates the AST generated by the parser.
- **Compiler** (C#): Generates C# code or IL from the AST for ahead-of-time compilation.
- **Hosting** (C#): Provides embedding API for hosting Lua in .NET applications.

## Documentation Index

### Core Documentation
- [README.md](README.md) - Main project documentation
- [FLua Gap Analysis](FLua-Gap-Analysis.md) - Lua 5.4 compatibility status
- [Architecture Compliance Report](ARCHITECTURE_COMPLIANCE_REPORT.md) - Architecture review
- [Lua Test Status Report](lua_test_status_report.md) - Test suite status

### Technical Documentation
- [Parser Known Issues](PARSER_KNOWN_ISSUES.md) - Current parser limitations
- [Error System Design](ERROR_SYSTEM_DESIGN.md) - Error handling architecture
- [Compiler TODO](TODO_COMPILER.md) - Compiler feature roadmap
- [Compiler Limitations](COMPILER_LIMITATIONS.md) - Known compiler limitations
- [Lua 5.4 Grammar](FLua/Lua54-grammar.md) - Language grammar reference

### Compiler Internals
- [Compiler Internals README](docs/compiler-internals/README.md) - Overview of compiler documentation
- [Lua 5.4 Language Fundamentals](docs/compiler-internals/lua-5.4-language-fundamentals.md) - Language design overview
- [FLua Compiler Architecture](docs/compiler-internals/flua-compiler-architecture.md) - Compiler design
- [Roslyn Syntax Generation](docs/compiler-internals/roslyn-syntax-generation.md) - C# code generation
- [Closure Compilation Limitations](docs/compiler-internals/closure-compilation-limitations.md) - Variable capture and closure challenges

### Examples and Usage
- [Examples README](examples/README.md) - Overview of all examples
- [Simple Script Execution](examples/SimpleScriptExecution/README.md) - Basic script running
- [Lambda Compilation](examples/LambdaCompilation/README.md) - Compiling to .NET delegates
- [Expression Tree Compilation](examples/ExpressionTreeCompilation/README.md) - Expression tree generation
- [Module Loading](examples/ModuleLoading/README.md) - Lua module system
- [AOT Compilation](examples/AotCompilation/README.md) - Native AOT compilation
- [Security Levels](examples/SecurityLevels/README.md) - Trust levels and sandboxing
- [Host Function Injection](examples/HostFunctionInjection/README.md) - .NET interop

### Test Documentation
- [Minimal Test Cases](FLua.Compiler.Tests.Minimal/TestCases/README.md) - Minimal compiler test suite
- [Variable Attributes Tests](FLua.VariableAttributes.Tests/README.md) - Lua 5.4 attribute testing

### Build and Publishing
- [Publishing README](README-publish.md) - Build and release process

## Getting Started

### Prerequisites
- .NET SDK (10.0 preview or later)
- F# Compiler
- Bash or Zsh shell (for build scripts)

### Installation Instructions
1. Clone the repository:
   ```bash
   git clone https://github.com/your-repo/flua.git
   cd flua
   ```

2. Build the project:
   ```bash
   dotnet build
   ```

3. Run tests:
   ```bash
   dotnet test
   ```

### Quick Start
See the [Simple Script Execution](examples/SimpleScriptExecution/README.md) example for basic usage.

## Current Status

### Recent Work (Session Summary)
- Fixed string concatenation in expression tree generation (using LuaOperations.Concat)
- Fixed math library access in expression trees (resolved AsFunction method ambiguity)
- Added local variable support in expression trees
- Cleaned up and organized test files

### Known Issues (Backlog)
1. **Module compilation with closures** - Architectural limitation when compiling modules that capture local variables
2. **Sandbox path restrictions** - Module resolver path checking is too restrictive for sandbox trust levels
3. **Nested module requires** - Issues with modules that require other modules
4. **Expression tree limitations**:
   - Function definitions not supported
   - Table constructors not supported
5. **Skipped tests** - Several hosting tests are currently skipped and need review

### Test Status
- Expression tree tests: 12/14 passing
- Hosting tests: 91/110 passing, 14 skipped, 5 failing
- Runtime tests: 2 failures in coroutine tests (fixed)

## FLua Hosting Model

The FLua hosting model allows embedding Lua scripts in .NET applications with various compilation targets and security levels.

### Key Features
1. **Multiple Compilation Targets**:
   - Interpreter (fallback, always available)
   - Lambda compilation (in-memory delegates)
   - Expression tree generation (for simple expressions)
   - Assembly compilation (persistent DLLs)
   - Native AOT compilation

2. **Security Levels**:
   - **Untrusted**: No file I/O, no dynamic code, minimal standard library
   - **Sandbox**: Limited file I/O in sandbox directories
   - **Restricted**: File I/O allowed except system directories
   - **Trusted**: Full standard library access
   - **FullTrust**: All features enabled

3. **Module System**:
   - File-based module resolution
   - Security-aware module loading
   - Module compilation and caching
   - Support for nested requires

### Architecture Components
- `ILuaHost` - Main hosting interface
- `IEnvironmentProvider` - Creates and configures Lua environments
- `ILuaCompiler` - Compilation backend interface
- `IModuleResolver` - Module loading interface
- `FilteredEnvironmentProvider` - Security-based environment filtering

## Development Guidelines

### Code Style
- Follow existing code patterns
- Use descriptive variable names
- Add XML documentation to public APIs
- Write tests for new features

### Testing
- Unit tests for all public APIs
- Integration tests for hosting scenarios
- Performance tests for compilation modes
- Security tests for trust levels

### Contributing
1. Check existing issues and discussions
2. Create feature branches from main
3. Add tests for new functionality
4. Update relevant documentation
5. Submit pull requests with clear descriptions

## Use Cases

### Lambda from Configuration
The primary use case is compiling Lua expressions from configuration files into strongly-typed .NET lambdas for high-performance evaluation:

```csharp
// The Lua expression uses named variables
string snippet = "a.prop1 * foo < 10";

// At runtime, we have the actual values
var complexObject = new SomeClass { prop1 = 5 };
var fooValue = 6;

public record Context(SomeClass A, int Foo);
// Either through a dictionary/context object:
var context = new Context(complexObject, fooValue);

// Need to bind the Lua variable names to the actual values
var ll = LuaLambdaCompiler.Create<Context, bool>(snippet, context);

public static class LuaLambdaCompiler
{
   public Func<TContext, TResult> Create<TContext, TResult>(string snippet, TContext context)
   { ... }
}
```

#### Requirements for This Use Case:
1. **Multiple statements** - Support full Lua scripts, not just expressions
2. **Name translation** - Map .NET naming (PascalCase) to Lua conventions (snake_case/camelCase)
   - `Context.SomeClass` → `some_class` or `someClass` in Lua
   - `object.PropName` → `prop_name` or `propName` in Lua
3. **Method calls** - Objects in context can have methods that Lua can invoke
4. **Return value** - The last statement/expression is the return value
5. **Direct .NET types** - No LuaValue wrapping, use native .NET types throughout
6. **High performance** - Compiled delegates should run at near-native speed
6. **Variable binding** - Need a way to connect expression variables to actual values

#### This Simplifies Our Architecture:
- Don't need full closure support (context is passed explicitly)
- Don't need bytecode VM (expressions are simple)
- Can use expression trees or IL generation
- Type inference from context type
- AOT compilation friendly

#### Implementation Approach:
1. Parse Lua expression to AST
2. Analyze context type via reflection
3. Generate expression tree or IL that:
   - Maps property access to context
   - Handles type conversions
   - Compiles to native delegate
4. Cache compiled delegates by expression + context type