using System;
using System.Collections.Generic;
using System.Linq;
using FLua.Ast;
using FLua.Parser;
using FLua.Runtime;
using Microsoft.FSharp.Collections;
using Microsoft.FSharp.Core;

namespace FLua.Interpreter
{
    /// <summary>
    /// Enhanced Lua interpreter with support for Lua 5.4 variable attributes
    /// </summary>
    public class EnhancedLuaInterpreter
    {
        private EnhancedLuaEnvironment _environment;

        public EnhancedLuaInterpreter()
        {
            _environment = EnhancedLuaEnvironment.CreateStandardEnvironment();
        }

        /// <summary>
        /// Evaluates a Lua expression and returns the result
        /// </summary>
        public LuaValue EvaluateExpression(string expressionText)
        {
            try
            {
                var expr = ParserHelper.ParseExpression(expressionText);
                return EvaluateExpr(expr);
            }
            catch (Exception ex)
            {
                throw new LuaRuntimeException($"Error evaluating expression: {ex.Message}");
            }
        }

        /// <summary>
        /// Executes Lua code and returns the result
        /// </summary>
        public LuaValue[] ExecuteCode(string code)
        {
            try
            {
                var ast = ParserHelper.ParseString(code);
                return ExecuteStatements(ast);
            }
            catch (Exception ex)
            {
                throw new LuaRuntimeException($"Error executing code: {ex.Message}");
            }
        }

        /// <summary>
        /// Executes a list of Lua statements
        /// </summary>
        private LuaValue[] ExecuteStatements(FSharpList<Statement> statements)
        {
            LuaValue[]? returnValues = null;
            bool breakFlag = false;
            string? gotoLabel = null;

            try
            {
                foreach (var stmt in statements)
                {
                    // Check for control flow interruptions
                    if (returnValues != null || breakFlag || gotoLabel != null)
                        break;

                    // Execute the statement
                    var result = ExecuteStatement(stmt);
                    
                    // Update control flow flags
                    returnValues = result.ReturnValues;
                    breakFlag = result.BreakFlag;
                    gotoLabel = result.GotoLabel;
                }
            }
            catch (LuaRuntimeException)
            {
                // Close to-be-closed variables with error
                _environment.CloseToBeClosedVariablesWithError(new LuaString("error during execution"));
                throw;
            }
            catch (Exception ex)
            {
                // Close to-be-closed variables with error
                _environment.CloseToBeClosedVariablesWithError(new LuaString($"Internal error: {ex.Message}"));
                throw new LuaRuntimeException($"Internal error: {ex.Message}");
            }

            // Normal exit - close to-be-closed variables normally
            if (returnValues != null || breakFlag || gotoLabel != null)
            {
                _environment.CloseToBeClosedVariables();
            }

            return returnValues ?? Array.Empty<LuaValue>();
        }

        /// <summary>
        /// Executes a list of Lua statements and returns a StatementResult
        /// </summary>
        private StatementResult ExecuteStatementsWithResult(FSharpList<Statement> statements)
        {
            StatementResult result = new StatementResult();

            try
            {
                foreach (var stmt in statements)
                {
                    // Check for control flow interruptions
                    if (result.ReturnValues != null || result.BreakFlag || result.GotoLabel != null)
                        break;

                    // Execute the statement
                    result = ExecuteStatement(stmt);
                }
            }
            catch (LuaRuntimeException)
            {
                // Close to-be-closed variables with error
                _environment.CloseToBeClosedVariablesWithError(new LuaString("error during execution"));
                throw;
            }
            catch (Exception ex)
            {
                // Close to-be-closed variables with error
                _environment.CloseToBeClosedVariablesWithError(new LuaString($"Internal error: {ex.Message}"));
                throw new LuaRuntimeException($"Internal error: {ex.Message}");
            }

            return result;
        }

        /// <summary>
        /// Executes a single Lua statement
        /// </summary>
        private StatementResult ExecuteStatement(Statement stmt)
        {
            if (stmt.IsEmpty)
            {
                return new StatementResult();
            }
            else if (stmt.IsLocalAssignment)
            {
                var localAssign = (Statement.LocalAssignment)stmt;
                var variables = localAssign.Item1;
                var expressions = localAssign.Item2;
                
                // Evaluate expressions if present
                LuaValue[] values = Array.Empty<LuaValue>();
                if (FSharpOption<FSharpList<Expr>>.get_IsSome(expressions))
                {
                    var exprList = expressions.Value.ToArray();
                    
                    if (exprList.Length > 0)
                    {
                        // Evaluate all expressions except the last one
                        var tempValues = new List<LuaValue>();
                        for (int i = 0; i < exprList.Length - 1; i++)
                        {
                            tempValues.Add(EvaluateExpr(exprList[i]));
                        }
                        
                        // The last expression might return multiple values
                        var lastExprValues = EvaluateExprWithMultipleReturns(exprList[exprList.Length - 1]);
                        tempValues.AddRange(lastExprValues);
                        values = tempValues.ToArray();
                    }
                }
                
                // Assign values to variables with attributes
                for (int i = 0; i < variables.Length; i++)
                {
                    var (name, attribute) = variables[i];
                    var value = i < values.Length ? values[i] : LuaNil.Instance;
                    
                    // Convert F# attribute to proper enum
                    var luaAttribute = ConvertAttribute(attribute);
                    _environment.SetLocalVariableWithAttribute(name, value, luaAttribute);
                }
                
                return new StatementResult();
            }
            else if (stmt.IsAssignment)
            {
                var assignStmt = (Statement.Assignment)stmt;
                var varExprs = assignStmt.Item1;
                var valueExprs = assignStmt.Item2;
                
                // Evaluate all value expressions
                var values = new List<LuaValue>();
                if (valueExprs.Length > 0)
                {
                    // Evaluate all expressions except the last one
                    for (int i = 0; i < valueExprs.Length - 1; i++)
                    {
                        values.Add(EvaluateExpr(valueExprs[i]));
                    }
                    
                    // The last expression might return multiple values
                    var lastExprValues = EvaluateExprWithMultipleReturns(valueExprs[valueExprs.Length - 1]);
                    values.AddRange(lastExprValues);
                }
                
                // Assign values to variables (this will check const violations)
                for (int i = 0; i < varExprs.Length; i++)
                {
                    var varExpr = varExprs[i];
                    var value = i < values.Count ? values[i] : LuaNil.Instance;
                    
                    if (varExpr.IsVar)
                    {
                        var varName = ((Expr.Var)varExpr).Item;
                        _environment.SetVariable(varName, value); // This will check const violations
                    }
                    else if (varExpr.IsTableAccess)
                    {
                        var tableAccess = (Expr.TableAccess)varExpr;
                        var tableValue = EvaluateExpr(tableAccess.Item1);
                        var keyValue = EvaluateExpr(tableAccess.Item2);
                        
                        if (tableValue is LuaTable table)
                        {
                            table.Set(keyValue, value);
                        }
                        else
                        {
                            throw new LuaRuntimeException("Attempt to index non-table");
                        }
                    }
                    else
                    {
                        throw new LuaRuntimeException("Invalid assignment target");
                    }
                }
                
                return new StatementResult();
            }
            else if (stmt.IsDoBlock)
            {
                var doBlockStmt = (Statement.DoBlock)stmt;
                var body = doBlockStmt.Item;
                
                // Create a new enhanced environment for the do block
                var blockEnv = new EnhancedLuaEnvironment(_environment);
                var originalEnv = _environment;
                
                try
                {
                    // Set the new environment
                    _environment = blockEnv;
                    
                    // Execute the block
                    var result = ExecuteStatementsWithResult(body);
                    
                    // Close to-be-closed variables before exiting scope
                    blockEnv.CloseToBeClosedVariables();
                    
                    return result;
                }
                catch (LuaRuntimeException)
                {
                    // Close to-be-closed variables with error
                    blockEnv.CloseToBeClosedVariablesWithError(new LuaString("error in do block"));
                    throw;
                }
                finally
                {
                    // Restore the original environment
                    _environment = originalEnv;
                }
            }
            // ... continue with other statement types using the original LuaInterpreter logic
            // For brevity, I'll delegate to the base implementation for other statements
            else
            {
                // For now, use the base interpreter for other statement types
                // In a full implementation, all statement types would be updated
                var baseInterpreter = new LuaInterpreter();
                return ExecuteStatementUsingBaseInterpreter(stmt, baseInterpreter);
            }
        }

        /// <summary>
        /// Converts F# Attribute to C# Attribute enum
        /// </summary>
        private Attribute ConvertAttribute(FLua.Parser.Attribute attribute)
        {
            // Note: This assumes FLua.Parser.Attribute exists and has similar values
            // You may need to adjust based on your actual F# attribute type
            switch (attribute.Tag)
            {
                case 0: return Attribute.NoAttribute;
                case 1: return Attribute.Const;
                case 2: return Attribute.Close;
                default: return Attribute.NoAttribute;
            }
        }

        /// <summary>
        /// Temporary method to delegate to base interpreter for unimplemented statements
        /// </summary>
        private StatementResult ExecuteStatementUsingBaseInterpreter(Statement stmt, LuaInterpreter baseInterpreter)
        {
            // This is a temporary bridge - in a full implementation, all statement handling
            // would be moved to this enhanced interpreter
            try
            {
                if (stmt.IsFunctionCall)
                {
                    var funcCall = (Statement.FunctionCall)stmt;
                    var expr = funcCall.Item;
                    EvaluateExpr(expr);
                    return new StatementResult();
                }
                else if (stmt.IsReturn)
                {
                    var returnStmt = (Statement.Return)stmt;
                    var expressions = returnStmt.Item;
                    
                    LuaValue[] values = Array.Empty<LuaValue>();
                    if (FSharpOption<FSharpList<Expr>>.get_IsSome(expressions))
                    {
                        var exprList = expressions.Value;
                        values = exprList.ToArray().Select(EvaluateExpr).ToArray();
                    }
                    else
                    {
                        values = new[] { LuaNil.Instance };
                    }
                    
                    return new StatementResult { ReturnValues = values };
                }
                else
                {
                    throw new NotImplementedException($"Statement type not yet implemented in enhanced interpreter: {stmt.GetType().Name}");
                }
            }
            catch (Exception ex)
            {
                throw new LuaRuntimeException($"Error executing statement: {ex.Message}");
            }
        }

        /// <summary>
        /// Evaluates a Lua expression (delegates to existing implementation for now)
        /// </summary>
        private LuaValue EvaluateExpr(Expr expr)
        {
            return EvaluateExprWithMultipleReturns(expr).FirstOrDefault() ?? LuaNil.Instance;
        }

        /// <summary>
        /// Evaluates a Lua expression and returns all values it produces
        /// </summary>
        private LuaValue[] EvaluateExprWithMultipleReturns(Expr expr)
        {
            // For now, delegate to a base interpreter instance
            // In a full implementation, this would be reimplemented here
            var baseInterpreter = new LuaInterpreter();
            
            if (expr.IsLiteral)
            {
                var literal = (Expr.Literal)expr;
                return new[] { EvaluateLiteral(literal.Item) };
            }
            else if (expr.IsVar)
            {
                var variable = (Expr.Var)expr;
                return new[] { _environment.GetVariable(variable.Item) };
            }
            // ... continue with other expression types
            else
            {
                throw new NotImplementedException($"Expression type not yet implemented in enhanced interpreter: {expr.GetType().Name}");
            }
        }

        /// <summary>
        /// Evaluates a Lua literal
        /// </summary>
        private LuaValue EvaluateLiteral(Literal literal)
        {
            if (literal.IsNil)
            {
                return LuaNil.Instance;
            }
            else if (literal.IsBoolean)
            {
                var boolLiteral = (Literal.Boolean)literal;
                return new LuaBoolean(boolLiteral.Item);
            }
            else if (literal.IsInteger)
            {
                var intLiteral = (Literal.Integer)literal;
                return new LuaInteger((long)intLiteral.Item);
            }
            else if (literal.IsFloat)
            {
                var floatLiteral = (Literal.Float)literal;
                return new LuaNumber(floatLiteral.Item);
            }
            else if (literal.IsString)
            {
                var stringLiteral = (Literal.String)literal;
                return new LuaString(stringLiteral.Item);
            }
            else
            {
                throw new NotImplementedException($"Literal type not implemented: {literal.GetType().Name}");
            }
        }
    }

    /// <summary>
    /// Represents the result of executing a statement
    /// </summary>
    public class StatementResult
    {
        public LuaValue[]? ReturnValues { get; set; }
        public bool BreakFlag { get; set; }
        public string? GotoLabel { get; set; }
    }
}
